{"version":3,"sources":["../src/util/parser.ts","../src/dmmfToSchema.ts","../src/schemaToDmmf.ts","../src/index.ts"],"sourcesContent":["import {\n  ConnectorType,\n  DataSource,\n  DMMF,\n  EnvValue,\n  GeneratorConfig,\n} from \"@prisma/generator-helper\";\nimport { printGeneratorConfig } from \"@prisma/engine-core\";\n\nexport interface Field {\n  kind: DMMF.FieldKind;\n  name: string;\n  isRequired: boolean;\n  isList: boolean;\n  isUnique: boolean;\n  isId: boolean;\n  type: string;\n  dbNames: string[] | null;\n  isGenerated: boolean;\n  hasDefaultValue: boolean;\n  relationFromFields?: any[];\n  relationToFields?: any[];\n  relationOnDelete?: string;\n  relationName?: string;\n  default: boolean | any;\n  isUpdatedAt: boolean;\n  isReadOnly: string;\n  columnName?: string;\n}\n\nexport interface Attribute {\n  isUnique: boolean;\n  isId: boolean;\n  dbNames: string[] | null;\n  relationFromFields?: any[];\n  relationToFields?: any[];\n  relationOnDelete?: string;\n  relationName?: string;\n  isReadOnly: string;\n  default?: boolean | any;\n  isGenerated: boolean;\n  isUpdatedAt: boolean;\n  columnName?: string;\n  comment?: string;\n}\n\nexport interface Model extends DMMF.Model {\n  uniqueFields: string[][];\n}\n\nconst handlers = (type: string, kind: DMMF.FieldKind) => {\n  return {\n    default: (value: unknown) => {\n      if (kind === \"enum\") {\n        return `@default(${value})`;\n      }\n\n      if (type === \"Boolean\") {\n        return `@default(${value})`;\n      }\n\n      if (typeof value === \"undefined\" || value === null) {\n        return \"\";\n      }\n\n      if (typeof value === \"object\") {\n        // @ts-ignore\n        return `@default(${value.name}(${value.args}))`;\n      }\n\n      if (typeof value === \"number\") {\n        return `@default(${value})`;\n      }\n\n      if (typeof value === \"string\") {\n        return `@default(\"${value}\")`;\n      }\n\n      throw new Error(`Unsupported field attribute ${value}`);\n    },\n    isId: (value: string) => (value ? \"@id\" : \"\"),\n    isUnique: (value: string) => (value ? \"@unique\" : \"\"),\n    dbNames: (value: string) => {},\n    dbName: (value: string) => (value ? `@map(\"${value}\")` : \"\"),\n    native: (value: string) => (value ? `${value}` : \"\"),\n    relationToFields: (value: string) => {},\n    relationOnDelete: (value: string) => {},\n    hasDefaultValue: (value: string) => {},\n    relationName: (value: string) => {},\n    documentation: (value: string) => {},\n    isReadOnly: (value: string) => {},\n    isGenerated: (value: string) => {},\n    isUpdatedAt: (value: string) => (value ? \"@updatedAt\" : \"\"),\n    columnName: (value: string) => (value ? `@map(\"${value}\")` : \"\"),\n    comment: (value: string) => (value ? `//${value}` : \"\"),\n  };\n};\n\nfunction handleAttributes(\n  attributes: Attribute,\n  kind: DMMF.FieldKind,\n  type: string\n) {\n  const { relationFromFields, relationToFields, relationName } = attributes;\n  if (kind === \"scalar\") {\n    return `${Object.keys(attributes)\n      // @ts-ignore\n      .map((each) => handlers(type, kind)[each](attributes[each]))\n      .join(\" \")}`;\n  }\n\n  if (kind === \"object\" && relationFromFields) {\n    return relationFromFields.length > 0\n      ? `@relation(name: \"${relationName}\", fields: [${relationFromFields}], references: [${relationToFields}])`\n      : `@relation(name: \"${relationName}\") ${\n          attributes?.comment ? \"//\" + attributes.comment : \"\"\n        }`;\n  }\n\n  if (kind === \"enum\")\n    return `${Object.keys(attributes)\n      // @ts-ignore\n      .map((each) => handlers(type, kind)[each](attributes[each]))\n      .join(\" \")}`;\n\n  return \"\";\n}\n\nfunction handleFields(fields: Field[]) {\n  return fields\n    .map((fields) => {\n      const { name, kind, type, isRequired, isList, ...attributes } = fields;\n      if (kind === \"scalar\") {\n        return `  ${name} ${type}${\n          isList ? \"[]\" : isRequired ? \"\" : \"?\"\n        } ${handleAttributes(attributes, kind, type)}`;\n      }\n\n      if (kind === \"object\") {\n        return `  ${name} ${type}${\n          isList ? \"[]\" : isRequired ? \"\" : \"?\"\n        } ${handleAttributes(attributes, kind, type)}`;\n      }\n\n      if (kind === \"enum\") {\n        return `  ${name} ${type}${\n          isList ? \"[]\" : isRequired ? \"\" : \"?\"\n        } ${handleAttributes(attributes, kind, type)}`;\n      }\n      if ((kind as any) === \"comment\") {\n        return `//${name}`;\n      }\n\n      throw new Error(`Unsupported field kind \"${kind}\"`);\n    })\n    .join(\"\\n\");\n}\n\nfunction handleIdFields(idFields: string[]) {\n  return idFields && idFields.length > 0\n    ? `@@id([${idFields.join(\", \")}])`\n    : \"\";\n}\n\nfunction handleUniqueFieds(uniqueFields: string[][]) {\n  return uniqueFields.length > 0\n    ? uniqueFields\n        .map((eachUniqueField) => `@@unique([${eachUniqueField.join(\", \")}])`)\n        .join(\"\\n\")\n    : \"\";\n}\n\nfunction handleDbName(dbName: string | null) {\n  return dbName ? `@@map(\"${dbName}\")` : \"\";\n}\n\nfunction handleUrl(envValue: EnvValue) {\n  const value = envValue.fromEnvVar\n    ? `env(\"${envValue.fromEnvVar}\")`\n    : envValue.value;\n\n  return `url = ${value}`;\n}\n\nfunction handleProvider(provider: ConnectorType | string) {\n  return `provider = \"${provider}\"`;\n}\n\nfunction deserializeModel(model: Model) {\n  const { name, uniqueFields, dbName, idFields, index } = model;\n  const fields = model.fields as unknown as Field[];\n\n  const output = `\nmodel ${name} {\n${handleFields(fields)}\n${handleUniqueFieds(uniqueFields)}\n${handleDbName(dbName)}\n${handleIdFields(idFields)}\n${index || \"\"}\n}`;\n  return output;\n}\n\nfunction deserializeDatasource(datasource: DataSource) {\n  const { activeProvider: provider, name, url } = datasource;\n\n  return `\ndatasource ${name} {\n\t${handleProvider(provider)}\n\t${handleUrl(url)}\n}`;\n}\n\nfunction deserializeEnum({ name, values, dbName }: DMMF.DatamodelEnum) {\n  const outputValues = values.map(({ name, dbName }) => {\n    let result = name;\n    if (name !== dbName && dbName) result += `@map(\"${dbName}\")`;\n    return result;\n  });\n  return `\nenum ${name} {\n\t${outputValues.join(\"\\n\\t\")}\n\t${handleDbName(dbName || null)}\n}`;\n}\n\nexport async function dmmfModelsdeserializer(models: Model[]) {\n  return models.map((model) => deserializeModel(model)).join(\"\\n\");\n}\n\nexport async function datasourcesDeserializer(datasources: DataSource[]) {\n  return datasources\n    .map((datasource) => deserializeDatasource(datasource))\n    .join(\"\\n\");\n}\n\nexport async function generatorsDeserializer(generators: GeneratorConfig[]) {\n  return generators\n    .map((generator) => printGeneratorConfig(generator))\n    .join(\"\\n\");\n}\n\nexport async function dmmfEnumsDeserializer(enums: DMMF.DatamodelEnum[]) {\n  return enums.map((each) => deserializeEnum(each)).join(\"\\n\");\n}\n","import {\n  datasourcesDeserializer,\n  dmmfEnumsDeserializer,\n  dmmfModelsdeserializer,\n  generatorsDeserializer,\n} from \"./util/parser\";\nimport { ConfigMetaFormat, formatSchema } from \"@prisma/internals\";\nimport { DMMF } from \"@prisma/generator-helper\";\n\nexport const dmmfToSchema = async ({\n  dmmf: { models, enums },\n  config: { datasources, generators },\n}: {\n  dmmf: DMMF.Document[\"datamodel\"];\n  config: ConfigMetaFormat;\n}) => {\n  const outputSchema = [\n    await datasourcesDeserializer(datasources),\n    await generatorsDeserializer(generators),\n    await dmmfModelsdeserializer(models),\n    await dmmfEnumsDeserializer(enums),\n  ]\n    .filter((e) => e)\n    .join(\"\\n\\n\\n\");\n\n  return await formatSchema({ schema: outputSchema });\n};\n","import { getConfig, getDMMF } from \"@prisma/internals\";\nimport stripAnsi from \"strip-ansi\";\n\nexport interface SchemaError {\n  reason: string;\n  row: string;\n}\n\nexport enum ErrorTypes {\n  Prisma,\n  Other,\n}\n\nexport const schemaToDmmf = async (schema: string) => {\n  try {\n    const { datamodel } = await getDMMF({\n      datamodel: schema,\n    });\n    const config = await getConfig({\n      datamodel: schema,\n      ignoreEnvVarErrors: true,\n    });\n\n    const lines = schema.split(\"\\n\");\n    let model = \"\";\n    lines.forEach((line, index) => {\n      if (line.includes(\"model\")) model = line.trim().split(\" \")[1];\n      if (line.includes(\"@db\")) {\n        const lineWords = line.trim().split(\" \");\n        const field = lineWords[0];\n        const nativeAttribute = lineWords[2];\n        const dmmfModel = datamodel.models.find((m) => m.name === model);\n        const dmmfField = dmmfModel?.fields.find((f) => f.name === field);\n\n        if (dmmfField) dmmfField[\"native\"] = nativeAttribute;\n      }\n      if (line.includes(\"//\")) {\n        const dmmfModel = datamodel.models.find((m) => m.name === model);\n        const lineWords = line.trim().split(\" \");\n        const comment = line.trim().split(\"//\")[1];\n        const isCommentLine = lineWords[0].includes(\"//\");\n        if (!isCommentLine) {\n          const field = lineWords[0];\n          const dmmfField = dmmfModel?.fields.find((f) => f.name === field);\n          if (dmmfField) dmmfField[\"comment\"] = comment;\n        } else {\n          const lastLine = lines[index - 1];\n          const lineWords = lastLine.trim().split(\" \");\n          const field = lineWords[0];\n          if (field === \"model\") {\n            dmmfModel?.fields.unshift({\n              kind: \"comment\",\n              name: comment,\n            } as any);\n          } else {\n            const dmmfFieldIndex = dmmfModel?.fields.findIndex(\n              (f) => f.name === field\n            );\n            if (dmmfFieldIndex)\n              dmmfModel?.fields.splice(dmmfFieldIndex + 1, 0, {\n                kind: \"comment\",\n                name: comment,\n              } as any);\n          }\n        }\n      }\n      if (line.includes(\"@@index\")) {\n        const index = line.trim();\n        const dmmfModel = datamodel.models.find((m) => m.name === model);\n\n        if (dmmfModel) dmmfModel[\"index\"] = index;\n      }\n    });\n\n    return { datamodel, config };\n  } catch (error) {\n    const message = stripAnsi((error as Error).message);\n    let errors: SchemaError[];\n    let errType: ErrorTypes;\n\n    if (message.includes(\"error: \")) {\n      errors = parseDMMFError(message);\n      errType = ErrorTypes.Prisma;\n    } else {\n      console.error(error);\n      errors = [{ reason: message, row: \"0\" }];\n      errType = ErrorTypes.Other;\n    }\n\n    return { errors, type: errType };\n  }\n};\n\nconst errRegex =\n  /^(?:Error validating.*?:)?(.+?)\\n  -->  schema\\.prisma:(\\d+)\\n/;\n\nconst parseDMMFError = (error: string): SchemaError[] =>\n  error\n    .split(\"error: \")\n    .slice(1)\n    .map((msg) => msg.match(errRegex)!.slice(1))\n    .map(([reason, row]) => ({ reason, row }));\n","export * from \"./dmmfToSchema\";\nexport * from \"./schemaToDmmf\";\nexport * from \"@prisma/generator-helper\";\nexport { type ConfigMetaFormat } from \"@prisma/internals\";\n"],"mappings":";AAOA,SAAS,4BAA4B;AA2CrC,IAAM,WAAW,CAAC,MAAc,SAAyB;AACvD,SAAO;AAAA,IACL,SAAS,CAAC,UAAmB;AAC3B,UAAI,SAAS,QAAQ;AACnB,eAAO,YAAY;AAAA,MACrB;AAEA,UAAI,SAAS,WAAW;AACtB,eAAO,YAAY;AAAA,MACrB;AAEA,UAAI,OAAO,UAAU,eAAe,UAAU,MAAM;AAClD,eAAO;AAAA,MACT;AAEA,UAAI,OAAO,UAAU,UAAU;AAE7B,eAAO,YAAY,MAAM,QAAQ,MAAM;AAAA,MACzC;AAEA,UAAI,OAAO,UAAU,UAAU;AAC7B,eAAO,YAAY;AAAA,MACrB;AAEA,UAAI,OAAO,UAAU,UAAU;AAC7B,eAAO,aAAa;AAAA,MACtB;AAEA,YAAM,IAAI,MAAM,+BAA+B,OAAO;AAAA,IACxD;AAAA,IACA,MAAM,CAAC,UAAmB,QAAQ,QAAQ;AAAA,IAC1C,UAAU,CAAC,UAAmB,QAAQ,YAAY;AAAA,IAClD,SAAS,CAAC,UAAkB;AAAA,IAAC;AAAA,IAC7B,QAAQ,CAAC,UAAmB,QAAQ,SAAS,YAAY;AAAA,IACzD,QAAQ,CAAC,UAAmB,QAAQ,GAAG,UAAU;AAAA,IACjD,kBAAkB,CAAC,UAAkB;AAAA,IAAC;AAAA,IACtC,kBAAkB,CAAC,UAAkB;AAAA,IAAC;AAAA,IACtC,iBAAiB,CAAC,UAAkB;AAAA,IAAC;AAAA,IACrC,cAAc,CAAC,UAAkB;AAAA,IAAC;AAAA,IAClC,eAAe,CAAC,UAAkB;AAAA,IAAC;AAAA,IACnC,YAAY,CAAC,UAAkB;AAAA,IAAC;AAAA,IAChC,aAAa,CAAC,UAAkB;AAAA,IAAC;AAAA,IACjC,aAAa,CAAC,UAAmB,QAAQ,eAAe;AAAA,IACxD,YAAY,CAAC,UAAmB,QAAQ,SAAS,YAAY;AAAA,IAC7D,SAAS,CAAC,UAAmB,QAAQ,KAAK,UAAU;AAAA,EACtD;AACF;AAEA,SAAS,iBACP,YACA,MACA,MACA;AACA,QAAM,EAAE,oBAAoB,kBAAkB,aAAa,IAAI;AAC/D,MAAI,SAAS,UAAU;AACrB,WAAO,GAAG,OAAO,KAAK,UAAU,EAE7B,IAAI,CAAC,SAAS,SAAS,MAAM,IAAI,EAAE,MAAM,WAAW,KAAK,CAAC,EAC1D,KAAK,GAAG;AAAA,EACb;AAEA,MAAI,SAAS,YAAY,oBAAoB;AAC3C,WAAO,mBAAmB,SAAS,IAC/B,oBAAoB,2BAA2B,qCAAqC,uBACpF,oBAAoB,mBAClB,yCAAY,WAAU,OAAO,WAAW,UAAU;AAAA,EAE1D;AAEA,MAAI,SAAS;AACX,WAAO,GAAG,OAAO,KAAK,UAAU,EAE7B,IAAI,CAAC,SAAS,SAAS,MAAM,IAAI,EAAE,MAAM,WAAW,KAAK,CAAC,EAC1D,KAAK,GAAG;AAEb,SAAO;AACT;AAEA,SAAS,aAAa,QAAiB;AACrC,SAAO,OACJ,IAAI,CAACA,YAAW;AACf,UAAM,EAAE,MAAM,MAAM,MAAM,YAAY,WAAW,WAAW,IAAIA;AAChE,QAAI,SAAS,UAAU;AACrB,aAAO,KAAK,QAAQ,OAClB,SAAS,OAAO,aAAa,KAAK,OAChC,iBAAiB,YAAY,MAAM,IAAI;AAAA,IAC7C;AAEA,QAAI,SAAS,UAAU;AACrB,aAAO,KAAK,QAAQ,OAClB,SAAS,OAAO,aAAa,KAAK,OAChC,iBAAiB,YAAY,MAAM,IAAI;AAAA,IAC7C;AAEA,QAAI,SAAS,QAAQ;AACnB,aAAO,KAAK,QAAQ,OAClB,SAAS,OAAO,aAAa,KAAK,OAChC,iBAAiB,YAAY,MAAM,IAAI;AAAA,IAC7C;AACA,QAAK,SAAiB,WAAW;AAC/B,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,IAAI,MAAM,2BAA2B,OAAO;AAAA,EACpD,CAAC,EACA,KAAK,IAAI;AACd;AAEA,SAAS,eAAe,UAAoB;AAC1C,SAAO,YAAY,SAAS,SAAS,IACjC,SAAS,SAAS,KAAK,IAAI,QAC3B;AACN;AAEA,SAAS,kBAAkB,cAA0B;AACnD,SAAO,aAAa,SAAS,IACzB,aACG,IAAI,CAAC,oBAAoB,aAAa,gBAAgB,KAAK,IAAI,KAAK,EACpE,KAAK,IAAI,IACZ;AACN;AAEA,SAAS,aAAa,QAAuB;AAC3C,SAAO,SAAS,UAAU,aAAa;AACzC;AAEA,SAAS,UAAU,UAAoB;AACrC,QAAM,QAAQ,SAAS,aACnB,QAAQ,SAAS,iBACjB,SAAS;AAEb,SAAO,SAAS;AAClB;AAEA,SAAS,eAAe,UAAkC;AACxD,SAAO,eAAe;AACxB;AAEA,SAAS,iBAAiB,OAAc;AACtC,QAAM,EAAE,MAAM,cAAc,QAAQ,UAAU,MAAM,IAAI;AACxD,QAAM,SAAS,MAAM;AAErB,QAAM,SAAS;AAAA,QACT;AAAA,EACN,aAAa,MAAM;AAAA,EACnB,kBAAkB,YAAY;AAAA,EAC9B,aAAa,MAAM;AAAA,EACnB,eAAe,QAAQ;AAAA,EACvB,SAAS;AAAA;AAET,SAAO;AACT;AAEA,SAAS,sBAAsB,YAAwB;AACrD,QAAM,EAAE,gBAAgB,UAAU,MAAM,IAAI,IAAI;AAEhD,SAAO;AAAA,aACI;AAAA,GACV,eAAe,QAAQ;AAAA,GACvB,UAAU,GAAG;AAAA;AAEhB;AAEA,SAAS,gBAAgB,EAAE,MAAM,QAAQ,OAAO,GAAuB;AACrE,QAAM,eAAe,OAAO,IAAI,CAAC,EAAE,MAAAC,OAAM,QAAAC,QAAO,MAAM;AACpD,QAAI,SAASD;AACb,QAAIA,UAASC,WAAUA;AAAQ,gBAAU,SAASA;AAClD,WAAO;AAAA,EACT,CAAC;AACD,SAAO;AAAA,OACF;AAAA,GACJ,aAAa,KAAK,KAAM;AAAA,GACxB,aAAa,UAAU,IAAI;AAAA;AAE9B;AAEA,eAAsB,uBAAuB,QAAiB;AAC5D,SAAO,OAAO,IAAI,CAAC,UAAU,iBAAiB,KAAK,CAAC,EAAE,KAAK,IAAI;AACjE;AAEA,eAAsB,wBAAwB,aAA2B;AACvE,SAAO,YACJ,IAAI,CAAC,eAAe,sBAAsB,UAAU,CAAC,EACrD,KAAK,IAAI;AACd;AAEA,eAAsB,uBAAuB,YAA+B;AAC1E,SAAO,WACJ,IAAI,CAAC,cAAc,qBAAqB,SAAS,CAAC,EAClD,KAAK,IAAI;AACd;AAEA,eAAsB,sBAAsB,OAA6B;AACvE,SAAO,MAAM,IAAI,CAAC,SAAS,gBAAgB,IAAI,CAAC,EAAE,KAAK,IAAI;AAC7D;;;AC9OA,SAA2B,oBAAoB;AAGxC,IAAM,eAAe,OAAO;AAAA,EACjC,MAAM,EAAE,QAAQ,MAAM;AAAA,EACtB,QAAQ,EAAE,aAAa,WAAW;AACpC,MAGM;AACJ,QAAM,eAAe;AAAA,IACnB,MAAM,wBAAwB,WAAW;AAAA,IACzC,MAAM,uBAAuB,UAAU;AAAA,IACvC,MAAM,uBAAuB,MAAM;AAAA,IACnC,MAAM,sBAAsB,KAAK;AAAA,EACnC,EACG,OAAO,CAAC,MAAM,CAAC,EACf,KAAK,QAAQ;AAEhB,SAAO,MAAM,aAAa,EAAE,QAAQ,aAAa,CAAC;AACpD;;;AC1BA,SAAS,WAAW,eAAe;AACnC,OAAO,eAAe;AAOf,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,wBAAA;AACA,EAAAA,wBAAA;AAFU,SAAAA;AAAA,GAAA;AAKL,IAAM,eAAe,OAAO,WAAmB;AACpD,MAAI;AACF,UAAM,EAAE,UAAU,IAAI,MAAM,QAAQ;AAAA,MAClC,WAAW;AAAA,IACb,CAAC;AACD,UAAM,SAAS,MAAM,UAAU;AAAA,MAC7B,WAAW;AAAA,MACX,oBAAoB;AAAA,IACtB,CAAC;AAED,UAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,QAAI,QAAQ;AACZ,UAAM,QAAQ,CAAC,MAAM,UAAU;AAC7B,UAAI,KAAK,SAAS,OAAO;AAAG,gBAAQ,KAAK,KAAK,EAAE,MAAM,GAAG,EAAE;AAC3D,UAAI,KAAK,SAAS,KAAK,GAAG;AACxB,cAAM,YAAY,KAAK,KAAK,EAAE,MAAM,GAAG;AACvC,cAAM,QAAQ,UAAU;AACxB,cAAM,kBAAkB,UAAU;AAClC,cAAM,YAAY,UAAU,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,KAAK;AAC/D,cAAM,YAAY,uCAAW,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS;AAE3D,YAAI;AAAW,oBAAU,YAAY;AAAA,MACvC;AACA,UAAI,KAAK,SAAS,IAAI,GAAG;AACvB,cAAM,YAAY,UAAU,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,KAAK;AAC/D,cAAM,YAAY,KAAK,KAAK,EAAE,MAAM,GAAG;AACvC,cAAM,UAAU,KAAK,KAAK,EAAE,MAAM,IAAI,EAAE;AACxC,cAAM,gBAAgB,UAAU,GAAG,SAAS,IAAI;AAChD,YAAI,CAAC,eAAe;AAClB,gBAAM,QAAQ,UAAU;AACxB,gBAAM,YAAY,uCAAW,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS;AAC3D,cAAI;AAAW,sBAAU,aAAa;AAAA,QACxC,OAAO;AACL,gBAAM,WAAW,MAAM,QAAQ;AAC/B,gBAAMC,aAAY,SAAS,KAAK,EAAE,MAAM,GAAG;AAC3C,gBAAM,QAAQA,WAAU;AACxB,cAAI,UAAU,SAAS;AACrB,mDAAW,OAAO,QAAQ;AAAA,cACxB,MAAM;AAAA,cACN,MAAM;AAAA,YACR;AAAA,UACF,OAAO;AACL,kBAAM,iBAAiB,uCAAW,OAAO;AAAA,cACvC,CAAC,MAAM,EAAE,SAAS;AAAA;AAEpB,gBAAI;AACF,qDAAW,OAAO,OAAO,iBAAiB,GAAG,GAAG;AAAA,gBAC9C,MAAM;AAAA,gBACN,MAAM;AAAA,cACR;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,SAAS,SAAS,GAAG;AAC5B,cAAMC,SAAQ,KAAK,KAAK;AACxB,cAAM,YAAY,UAAU,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,KAAK;AAE/D,YAAI;AAAW,oBAAU,WAAWA;AAAA,MACtC;AAAA,IACF,CAAC;AAED,WAAO,EAAE,WAAW,OAAO;AAAA,EAC7B,SAAS,OAAP;AACA,UAAM,UAAU,UAAW,MAAgB,OAAO;AAClD,QAAI;AACJ,QAAI;AAEJ,QAAI,QAAQ,SAAS,SAAS,GAAG;AAC/B,eAAS,eAAe,OAAO;AAC/B,gBAAU;AAAA,IACZ,OAAO;AACL,cAAQ,MAAM,KAAK;AACnB,eAAS,CAAC,EAAE,QAAQ,SAAS,KAAK,IAAI,CAAC;AACvC,gBAAU;AAAA,IACZ;AAEA,WAAO,EAAE,QAAQ,MAAM,QAAQ;AAAA,EACjC;AACF;AAEA,IAAM,WACJ;AAEF,IAAM,iBAAiB,CAAC,UACtB,MACG,MAAM,SAAS,EACf,MAAM,CAAC,EACP,IAAI,CAAC,QAAQ,IAAI,MAAM,QAAQ,EAAG,MAAM,CAAC,CAAC,EAC1C,IAAI,CAAC,CAAC,QAAQ,GAAG,OAAO,EAAE,QAAQ,IAAI,EAAE;;;ACnG7C,cAAc;AACd,eAAsC;","names":["fields","name","dbName","ErrorTypes","lineWords","index"]}